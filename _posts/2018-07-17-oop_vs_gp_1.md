---
layout: post
title: 面向对象与泛型编程 part.1
categories: moderncpp
---

## 1. 因为抽象
抽象是我们常用的思维过程。一系列事物通过大脑的提炼，归纳和综合，让我们可以从无序中找出有序，从一个个具体的问题中找出通用的解决方法。数学家们最为擅长抽象，他们甚至不关心具体的研究对象（模型），只研究对象之间的某种联系（理论）。他们只关心他们所抽象出的理论在整个模型空间适用的广度。程序也经常使用抽象，把许多具体繁琐的事务的共同点提炼出来，用统一的过程进行调度，从而实现复杂的业务需求。面向对象的程序设计（下文称为OOP），及泛型编程（下文称为GP）都大量使用了抽象。鄙文将会讨论OOP中常见的抽象方法，非OOP中的抽象类，并会讨论OOP中抽象的局限性。GP有着更强大的抽象能力，由于GP起于C++编程语言，鄙文还会讨论GP在C++语言历史中的限制，以及现代C++的发展所带来的变化。鄙文不是引战OOP与GP孰优孰劣，而是以抽象为线索，探讨如何编写出能应付更加复杂程序的方法。

## 2. 传统OOP中的抽象
OOP有一个经典的案例。鱼会游泳，鸟会飞行，而它们都是动物。于是用OOP就很自然的有了下面的代码：
```cpp
class animal {
public:
    virtual char const* species() = 0;
};

class bird : public animal {
public:
    char const* species() override {
        return "bird";
    }

    virtual void fly() {
        std::cout << "bird::fly" << std::endl;
    }
};

class fish : public animal {
public:
    char const* species() override {
        return "fish";
    }

    virtual void swim() {
        std::cout << "fish::swim" << std::endl;
    }
};
```
许多文章和书籍对OOP都是这样教的。从animal继承以扩展新的动物类，如哺乳类。从bird或fish继承，以扩展出具体的物种。当然还有许多文章也拿这个例子作为OOP的反面教材。因为当我们要实现飞鱼的时候，飞鱼既可以游泳，也可以飞行，这个继承结构无所适从。那么究竟是哪里出了问题？

熟悉OOP的人会说，这里违反了里氏替换原则。飞鱼属于鱼类，但是我们抽象的鱼类无法满足要求。如果给鱼增加一个fly接口：
```cpp
class fish : public animal {
public:
    char const* species() override {
        return "fish";
    }

    virtual void swim() {
        std::cout << "fish::swim" << std::endl;
    }

    virtual void fly() {
        std::cout << "I can`t fly" << std::endl;
    }
};

class flying_fish : public fish {
public:
    void fly() override {
        std::cout << "flying_fish::fly" << std::endl;
    }
};
```
能解决飞鱼这一个情况，但是天鹅属于鸟类，但是它既会走路，也会飞行，当然也会游泳。这个时候我们又不得不扩充我们的鸟类的接口。问题似乎变复杂了，绝大部分的鱼并不会游泳，但是为了兼容飞鱼我们为鱼类添加了fly接口。其实，真正的问题在于，我们为了实现一个可以游泳的动物，根据有限的经验抽象出了鱼类，并把这个动物归为鱼类。这种抽象的方式的代价，就是实现类与抽象类之间，多了一个is_a的关系，这个关系是一个很强的依赖关系。为了让飞鱼飞翔起来，通常情况下我们必须使用fish对象的fly接口的多态特性。

对动物的抽象而言，这种错误很容易发现，这是得益于我们的基础教育。但是现实的问题往往都是未充分了解的，所以不符合里氏替换原则的情况，比比皆是。其次，仅仅使用接口的异同类对事物进行抽象和归属，本来就是一个错误的设计。于是OOP就有了改良，提出了接口编程。

## 3. 接口编程与行为抽象
来到了接口编程，OOP不再抽象类属了，而是抽象行为。例如，上面的例子，我们不再为动物区分哺乳类，鸟类和鱼类等，也不会为鱼类实现飞鱼或者鲈鱼等其他具体的物种。我们改为对行走，游泳和飞行等行为的抽象。
``` cpp
class flyable {
public:
    virtual void fly() = 0;
};

class walkable {
public:
    virtual void walk() = 0;
};

class swimmable {
public:
    virtual void swim() = 0;
};
```
于是，飞鱼的问题就很好解决了：
```cpp
class flying_fish 
    : public flyable
    , public swimmable {
public:
    void fly() override {
        std::cout << "flying_fish::fly" << std::endl;
    }

    void swim() override {
        std::cout << "flying_fish::swim" << std::endl;
    }
};
```
一开始我们只在抽象动物，但是目前的设计好像还能推广的更远。例如，实现飞机也很容易:
```cpp
class plane : public flyable {
public:
    void fly() override {
        std::cout << "plane::fly" << std::endl;
    }
};
```