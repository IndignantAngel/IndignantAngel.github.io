---
layout: post
title: 面向对象与泛型编程 part.1
categories: moderncpp
---

## 1. 因为抽象
抽象是我们常用的思维过程。一系列事物通过大脑的提炼，归纳和综合，让我们可以从无序中找出有序，从一个个具体的问题中找出通用的解决方法。数学家们最为擅长抽象，他们甚至不关心具体的研究对象（模型），只研究对象之间的某种联系（理论）。他们只关心他们所抽象出的理论在整个模型空间适用的广度。程序也经常使用抽象，把许多具体繁琐的事务的共同点提炼出来，用统一的过程进行调度，从而实现复杂的业务需求。面向对象的程序设计（下文称为OOP），及泛型编程（下文称为GP）都大量使用了抽象。鄙文将会讨论OOP中常见的抽象方法，非OOP中的抽象类，并会讨论OOP中抽象的局限性。GP有着更强大的抽象能力，由于GP起于C++编程语言，鄙文还会讨论GP在C++语言历史中的限制，以及现代C++的发展所带来的变化。鄙文不是引战OOP与GP孰优孰劣，而是以抽象为线索，探讨如何编写出能应付更加复杂程序的方法。

## 2. 传统OOP中的抽象
OOP有一个经典的案例。鱼会游泳，鸟会飞行，而它们都是动物。于是用OOP就很自然的有了下面的代码：
```cpp
class animal {
public:
    virtual char const* species() = 0;
};

class bird : public animal {
public:
    char const* species() override {
        return "bird";
    }

    virtual void fly() {
        std::cout << "bird::fly" << std::endl;
    }
};

class fish : public animal {
public:
    char const* species() override {
        return "fish";
    }

    virtual void swim() {
        std::cout << "fish::swim" << std::endl;
    }
};
```
许多文章和书籍对OOP都是这样教的。从animal继承以扩展新的动物类，如哺乳类。从bird或fish继承，以扩展出具体的物种。当然还有许多文章也拿这个例子作为OOP的反面教材。因为当我们要实现飞鱼的时候，飞鱼既可以游泳，也可以飞行，这个继承结构无所适从。那么究竟是哪里出了问题？

熟悉OOP的人会说，这里违反了里氏替换原则。飞鱼属于鱼类，但是我们抽象的鱼类无法满足要求。如果给鱼增加一个fly接口：
```cpp
class fish : public animal {
public:
    char const* species() override {
        return "fish";
    }

    virtual void swim() {
        std::cout << "fish::swim" << std::endl;
    }

    virtual void fly() {
        std::cout << "I can`t fly" << std::endl;
    }
};

class flying_fish : public fish {
public:
    void fly() override {
        std::cout << "flying_fish::fly" << std::endl;
    }
};
```
能解决飞鱼这一个情况，但是天鹅属于鸟类，但是它既会走路，也会飞行，当然也会游泳。这个时候我们又不得不扩充我们的鸟类的接口。问题似乎变复杂了，绝大部分的鱼并不会飞行，但是为了兼容飞鱼我们为鱼类添加了fly接口。其实，真正的问题在于，我们为了实现一个可以游泳的动物，根据有限的经验抽象出了鱼类，并把这个动物归为鱼类。这种抽象的方式的代价，就是实现类与抽象类之间，多了一个is_a的关系，这个关系是一个很强的依赖关系。为了让飞鱼飞翔起来，通常情况下我们必须使用fish对象的fly接口的多态特性。

对动物的抽象而言，这种错误很容易发现，这是得益于我们的基础教育。但是现实的问题往往都是未充分了解的，所以不符合里氏替换原则的情况，比比皆是。其次，仅仅使用接口的异同类对事物进行抽象和归属，本来就是一个错误的设计。于是OOP就有了改良，提出了接口编程。

## 3. 接口编程与行为抽象
来到了接口编程，OOP不再抽象类属了，而是抽象行为。例如，上面的例子，我们不再为动物区分哺乳类，鸟类和鱼类等，也不会为鱼类实现飞鱼或者鲈鱼等其他具体的物种。我们改为对行走，游泳和飞行等行为的抽象。
``` cpp
class flyable {
public:
    virtual void fly() = 0;
};

class walkable {
public:
    virtual void walk() = 0;
};

class swimmable {
public:
    virtual void swim() = 0;
};
```
于是，飞鱼的问题就很好解决了：
```cpp
class flying_fish 
    : public flyable
    , public swimmable {
public:
    void fly() override {
        std::cout << "flying_fish::fly" << std::endl;
    }

    void swim() override {
        std::cout << "flying_fish::swim" << std::endl;
    }
};
```
如果语言不支持多重继承，可以使用组合的方式实现。增加一个中间层，更啰嗦一些，但问题不大。回到正题，一开始我们只在抽象动物，但是目前的设计好像还能推广的更远。例如，实现飞机也很容易:
```cpp
class plane : public flyable {
public:
    void fly() override {
        std::cout << "plane::fly" << std::endl;
    }
};
```
现在我们要实现一个功能，让我们实现的飞鱼先飞行再游泳。好像碰到了点什么问题。是的，这样的设计也存在很大的问题。OOP的程序很依赖多态，也就是在运行期进行分派，所以我们只会通过flyable和swimmable接口对象来分别访问fly和swim接口。如何保证flyable和swimmable两个接口对象，都来自于同一个flying_fish对象，是一个不小的问题。再实现一个fly_then_swim的行为？
```cpp
class fly_then_swim_behavior {
public:
    virtual void fly_then_swim() = 0;
};

class flying_fish
    : public flyable
    , public swimmable
    , public fly_then_swim_behavior {
public:
    // ... omitted codes here
    void fly_then_swim() override {
        fly();
        std::cout << "flying_fish::fly_then_swim interval" << std::endl;
        swim();
    }
};
```
这种设计也很不明智。如果用固定的接口来框定各种行为的组合，那么这些接口类的数目是无穷尽的。并且这里也违反了开闭原则，为了达到目的而修改了实现。一个可行解决方法，就是我们为实体对象提供接口查询的功能，这个就与COM很相似了。
```cpp
using interface_base = void*;

class object_base {
public:
    virtual void query_interface(uuid_t id, interface_base*& i) = 0
};

class flyable {
public:
    uuid_t id;
    virtual void fly() = 0;
};

class swimmable {
    uuid_t id;
    virtuao void swim() = 0;
};

class flying_fish 
    : public object_base
    , public flyable
    , public swimmable {
public:
    // ... omitted codes here

    void query_interface(uuid_t id, object_base*& i) override {
        if(id == flyable::id){
            i = static_cast<flyable*>(this);
        } else if(id == swimmable::id) {
            i = static_cast<swimmable*>(this);
        } else {
            i = nullptr;
        }
    }
};

void fly_then_swim(object_base* obj) {
    interface_base fly, swim;
    obj->query_interface(flyable::id, fly);
    obj->query_interface(swimmable::id, swim);
    if(fly && swim) {
        reinterpret_cast<flyable*>(fly)->fly();
        reinterpret_cast<swimmable*>(swim)->swim();
    }
}
```
接口查询提供了一种机制，可以让程序提取出对象的接口，解决了多个接口可见性和一致性的问题。很多现代语言，都提供了反射机制，